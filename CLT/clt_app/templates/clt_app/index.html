<!DOCTYPE html>
<html>
  <meta charset="utf-8">
  <head>
  <style>
    body {
      font: 14px normal helvetica, sans-serif;
    }

    .bar {
      fill: steelblue;
    }

    .bar:hover {
      fill: brown;
    }

    .axis {
      font: 10px sans-serif;
    }

    .axis path,
    .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

    .x.axis path {
      display: none;
    }

    .btn {
      border: 1px solid black;
      padding: 3px;
    }
    .btn_start {
      border: 1px solid black;
      padding: 3px;
      background: green;
    }
    .btn_stop {
      border: 1px solid black;
      padding: 3px;
      background: red;
    }

    .quote {
      margin-left: 50px;
      padding-left: 15px;
      border-left: 3px solid #ccc;
    }

  </style>
  </head>
  <body>
    <h1>The Central Limit Theorem, a graphical exploration</h1>
    <p>
    From <a href="https://en.wikipedia.org/wiki/Central_limit_theorem">Wikipedia</a>:<br />
    <div class="quote">In probability theory, the central limit theorem (CLT) states that, given certain conditions, the arithmetic mean of a sufficiently large number of iterates of independent random variables, each with a well-defined expected value and well-defined variance, will be approximately normally distributed.[1] That is, suppose that a sample is obtained containing a large number of observations, each observation being randomly generated in a way that does not depend on the values of the other observations, and that the arithmetic average of the observed values is computed. If this procedure is performed many times, the central limit theorem says that the computed values of the average will be distributed according to the normal distribution (commonly known as a "bell curve").</div>
    </p>

    <p>
    <b>Whew.</b> I don't know about you, but that sounds complicated. Let's try and state it simply:<br />
    When you take many sample measurements, the mean of those samples will form a bell curve shaped (normal) distribution.<br />
    That sounds much friendlier. This tool will help you to explore exactly what that means and gain a intuitive visual understanding of the phenomenon.
    </p>

    <p>
    Let's start by looking at randomness in general. The next graph shows how many times a given number is returned by a random number generator choosing a number between 1 and 10.<br />
    (This example uses Python's cryptographically secure random number generator.)
    </p>
    <div id="graph1_cont">
      <span id="graph1_toggle" class="btn_start" onClick="toggleGraph1()">Start</span> (ms between requests: <input type="text" id="graph1_speed" value="100">)
      <span id="graph1_reset" class="btn" onClick="resetGraph1()">Reset</span>
      Number of Samples: <span id="graph1_counter">0</span><br />
      <input type="radio" class="gr1_rd" name="graph1_rd" value="random_integer" checked="true"/> "Normal" random generator<br />
      <input type="radio" class="gr1_rd" name="graph1_rd" value="crypto_random" /> Cryptographically secure random generator
      <div id="graph1"></div>
    </div>

    <p>
    That should look pretty evenly random right? And if you run it multiple times you sholud see different results, sometimes with tall spikes at certain numbers, sometimes with a very even distribution between all numbers.<br />
    Let's try the same experiment a second way, just to see. This time we're using python's standard (non-cryptographically-secure) random number generator.)
    </p>

    <p>
    Leave either of these running for long enough, and repeat the experiment enough times, and you should notice no real pattern to this randomness. It could be slightly different each time, but you won't see any regular shape appearing time after time.<br />
    This is how we expect random generation to behave, and we've now verified that our random number generation is working correctly.<br />
    <br />
    So in our next scenario we'll try something else. Imagine we use our verified random number generator to create a very long list of random 1's and 0's. Then take a <i>sample</i> by pulling out 50 characters of that string, and count the number of 0's in that sample.<br />
    We'll take these samples, and graph them, showing us how many 0's appeared. What would you expect the graph of those results to look like? Let's give it a try!
    </p>

    <div id="graph2_cont">
      <span id="graph2_toggle" class="btn_start" onClick="toggleGraph2()">Start</span> (ms between requests: <input type="text" id="graph2_speed" value="100">)
      <span id="graph2_reset" class="btn" onClick="resetGraph2()">Reset</span>
      Number of Samples: <span id="graph2_counter">0</span><br />
      <input type="radio" class="gr2_rd" name="graph2_rd" value="random_slice" checked="true"/> Random Samples<br />
      <input type="radio" class="gr2_rd" name="graph2_rd" value="contig_random_slice" /> Contiguous Samples
      <div id="graph2"></div>
    </div>

    <p>
    You may have to let it run for a bit before the curve really smooths out, try waiting for at least a thousand samples, but in the end you should begin to see a nice bell curve!<br />
    This may not seem intuitive, but it perfectly illustrates the idea of the Central Limit Theorem! No matter what the underlying data is, these random samples will turn out to follow this normal curve.
    The above graph has two different ways of taking samples. One takes 50 random samples scattered from somewhere inside the large number. The second picks a starting point, and takes 50 contiguous numbers beginning there. If you run the experiment several times and test both methods you can see that both eventually get you to a bell-curved shape, but that the contiguous method takes longer. (At least 3 times as many samples as a rough approximation.)<br />
    </p>

    <p>
    But hold on... Could it be that our underlying data just leads us to this result? Would using a different dataset change the result? What if we used a very skewed dataset?<br />
    Let's try the same experiment, but this time our very long number, rather than being filled with completely random 1's and 0's, will be filled with 75% 0's, followed by 25% 1's.
    There are three ways you can run the experiment:
    1) Contiguous chunks of 50. (This takes a single block of 50 out of the list and counts it.
    2) 50 random items out of our nonrandom list, but the list is only 1000 long.
    3) 50 random items out of our nonrandom list, but the list is 10,000 items long.
    </p>

    <div id="graph3_cont">
      <span id="graph3_toggle" class="btn_start" onClick="toggleGraph3()">Start</span> (ms between requests: <input type="text" id="graph3_speed" value="100">)
      <span id="graph3_reset" class="btn" onClick="resetGraph3()">Reset</span>
      Number of Samples: <span id="graph3_counter">0</span><br />
      <input type="radio" class="gr3_rd" name="graph3_rd" value="contig_nonrandom_slice" checked="true" /> Contiguous Normal (750 0's, 250 1's)<br />
      <input type="radio" class="gr3_rd" name="graph3_rd" value="nonrandom_slice" /> Normal (750 0's, 250 1's)<br />
      <input type="radio" class="gr3_rd" name="graph3_rd" value="long_nonrandom_slice" /> Long (7500 0's, 2500 1's)
      <div id="graph3"></div>
    </div>

    <p>
    In this example the contiguous test method shows a <b>very</b> skewed result, and does not look like a bell curve at all. If you were to throw away the outliers at the far ends of the graph the remaining data points do appear to form what could be a curve, which is worthless since the outlies contain most of the results, but it is interesting to observe.<br />
    Given this, we can infer that for skewed underlying datasets it becomes increasingly important to correctly randomize your sample collection. If your randomization algorithm leads "clumping" in your sample selection you will not see the effects of the CLT on the sample mean graph.<br />
    Both of the random methods further illustrate the CLT though, as we can see that the bell curve of normality centers right on the 75% mark, apparently independently of the length of the random string!<br />
    This example makes a bit more intuitive sense. A string of all 1's should be relatively rare, a string of all 0's should be slightly more common, but most common sholud be some string that has a few of both.
    </p>

    <p>
    So that's the Central Limit Theorem! Why this is useful is left as a much larger educational exercise, but for now it's enough to observe that it does work. :-)
    </p>

    <div id="infobox" style="display:none; background:red; position:absolute;"></div>

    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script>

    var margin = {top: 20, right: 20, bottom: 30, left: 40},
        width = 760 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;

    function get_radio_value(rd_id) {
      var btns = document.getElementsByClassName(rd_id);
      for (var i=0; i < btns.length; i++) {
        if (btns[i].checked) {
            return btns[i].value;
          }
       }
    }
    /********** Tooltip Functions **********/

    var tooltipOver = function() {
      d3.select("#infobox").style("display", "block");
      d3.select("#infobox").text(this.__data__.name + " occurred "+this.__data__.frequency+" times.");
    }

    var tooltipOut = function() {
      d3.select("#infobox").style("display", "none");
    }

    // The tooltip just always moves around... Good thing we have CPU cycles to spare. 
    var tooltipMove = function() {
      var infobox = d3.select("#infobox");
      var coord = d3.mouse(this)
      infobox.style("left", coord[0] + 15 + "px" );
      infobox.style("top", coord[1] + "px");
    }
    d3.select("body").on('mousemove', tooltipMove);


    /********** GRAPH 1 **********/

    // Set up and populate the data array for graph1
    var g1_data = [];
    var oneToEleven = new Array();
    for(var i=0; i<11; i++) {
      oneToEleven[i] = i;
      g1_data[i] = {name: i, frequency:0 }
    }

    var g1_counter = 0;

    var g1_barWidth = width/g1_data.length;

    var g1_x = d3.scale.linear()
              .domain(g1_data.map(function(d) { return d.name; }))
              .range([0, 70]);

    var g1_y = d3.scale.linear()
        .range([height, 0]);

    var g1_xAxis = d3.svg.axis()
        .scale(g1_x)
        .orient("bottom");

    var g1_yAxis = d3.svg.axis()
        .scale(g1_y)
        .orient("left");

    var g1_svg = d3.select("#graph1").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Draw graph 1's initial state
    g1_y.domain([0, d3.max(g1_data, function(d) { return d.frequency; })]);

    g1_svg.append("g")
        .attr("class", "x-axis")
        .attr("transform", "translate(0," + height + ")")
        .call(g1_xAxis);

    g1_svg.append("g")
        .attr("class", "y-axis")
        .call(g1_yAxis)
      .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("Frequency");

    g1_svg.selectAll(".bar")
        .data(g1_data)
      .enter().append("rect")
        .attr("transform", function(d, i) { return "translate(" + i * g1_barWidth + ",0)"; })
        .attr("class", "bar")
        .attr("width", g1_barWidth-4)
        .attr("y", function(d) { return g1_y(d.frequency); })
        .attr("height", function(d) { return height - g1_y(d.frequency); })
        .on("mouseover", tooltipOver)
        .on("mouseout", tooltipOut);

    function g1_redraw() {
      g1_y.domain([0, d3.max(g1_data, function(d) { return d.frequency; })]);

      function calcTicks() {
        var m = d3.max(g1_data, function(d) { return d.frequency; })
        if(m<10)
          return m;
        else
          return 10;
      }

      g1_yAxis.ticks(calcTicks());
      g1_svg.selectAll("g .y-axis")
        .call(g1_yAxis);
      g1_svg.selectAll("g .x-axis")
        .call(g1_xAxis);

      var bars = g1_svg.selectAll(".bar")
        .data(g1_data)
        .attr("y", function(d) { return g1_y(d.frequency); })
        .attr("height", function(d) { return height-g1_y(d.frequency); })

      d3.select("#graph1_counter").text(g1_counter);
    }


    function graph1_update() {
      d3.json("/ajax/clt_app/"+get_radio_value("gr1_rd")+".json", function(err, j) { g1_data[j.data.integer].frequency++; g1_counter++; g1_redraw(); }).post()
    }

    var graph1TimerId;

    function toggleGraph1(){
      if(d3.select("#graph1_toggle").text() == "Start")
      {
        graph1TimerId = window.setInterval(graph1_update, document.getElementById("graph1_speed").value);
        d3.select("#graph1_toggle").text("Stop").attr("class", "btn_stop");
      }
      else
      {
        window.clearInterval(graph1TimerId);
        d3.select("#graph1_toggle").text("Start").attr("class", "btn_start");
      }
    }

    function resetGraph1(){
      g1_data.map(function(d){d.frequency=0;});
      g1_counter = 0;
      g1_redraw();
    }


    /********** GRAPH 2 **********/

    // Set up and populate the data array for graph1
    var g2_data = [];
    var oneToFifty = new Array();
    for(var i=0; i<50; i++) {
      oneToFifty[i] = i;
      g2_data[i] = {name: i, frequency:0 }
    }

    var g2_counter = 0;


    var g2_x = d3.scale.linear()
              .domain(oneToFifty)
              .range([0,10]); // ,width

    var g2_y = d3.scale.linear()
        .range([height, 0]);

    var g2_xAxis = d3.svg.axis()
        .scale(g2_x)
        .orient("bottom");

    var g2_yAxis = d3.svg.axis()
        .scale(g2_y)
        .orient("left");

    var g2_svg = d3.select("#graph2").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Draw graph 2's initial state
    g2_y.domain([0, d3.max(g2_data, function(d) { return d.frequency; })]);

    g2_svg.append("g")
        .attr("class", "x-axis")
        .attr("transform", "translate(0," + height + ")")
        .call(g2_xAxis);

    g2_svg.append("g")
        .attr("class", "y-axis")
        .call(g2_yAxis)
      .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("Frequency");

    g2_svg.selectAll(".bar")
        .data(g2_data)
      .enter().append("rect")
        .attr("class", "bar")
        .attr("x", function(d) { return g2_x(d.name); })
        .attr("width", 5)//x.rangeBand())
        .attr("y", function(d) { return g2_y(d.frequency); })
        .attr("height", function(d) { return height - g2_y(d.frequency); })
        .on("mouseover", tooltipOver)
        .on("mouseout", tooltipOut);

    function g2_redraw() {
      g2_y.domain([0, d3.max(g2_data, function(d) { return d.frequency; })]);

      function calc2Ticks() {
        var m = d3.max(g2_data, function(d) { return d.frequency; })
        if(m<10)
          return m;
        else
          return 10;
      }

      g2_yAxis.ticks(calc2Ticks());
      g2_svg.selectAll("g .y-axis")
         .call(g2_yAxis);

      var bars = g2_svg.selectAll(".bar")
        .data(g2_data)
        .attr("y", function(d) { return g2_y(d.frequency); })
        .attr("height", function(d) { return height-g2_y(d.frequency); })

      d3.select("#graph2_counter").text(g2_counter);
    }


    function graph2_update() {
      d3.json("/ajax/clt_app/"+get_radio_value("gr2_rd")+".json", function(err, j) { g2_data[j.data.sample_count_0].frequency++; g2_counter++; g2_redraw(); }).post()
    }

    var graph2TimerId;

    function toggleGraph2(){
      if(d3.select("#graph2_toggle").text() == "Start")
      {
        graph2TimerId = window.setInterval(graph2_update, document.getElementById("graph2_speed").value);
        d3.select("#graph2_toggle").text("Stop").attr("class", "btn_stop");
      }
      else
      {
        window.clearInterval(graph2TimerId);
        d3.select("#graph2_toggle").text("Start").attr("class", "btn_start");
      }
    }

    function resetGraph2(){
      g2_data.map(function(d){d.frequency=0;});
      g2_counter = 0;
      g2_redraw();
    }


    /********** GRAPH 3 **********/

    // Set up and populate the data array for graph1
    var g3_data = [];
    for(var i=0; i<50; i++) {
      g3_data[i] = {name: i, frequency:0 }
    }

    var g3_counter = 0;


    var g3_x = d3.scale.linear()
              .domain(oneToFifty)
              .range([0,10]); // ,width

    var g3_y = d3.scale.linear()
        .range([height, 0]);

    var g3_xAxis = d3.svg.axis()
        .scale(g3_x)
        .orient("bottom");

    var g3_yAxis = d3.svg.axis()
        .scale(g3_y)
        .orient("left");

    var g3_svg = d3.select("#graph3").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Draw graph 3's initial state
    g3_y.domain([0, d3.max(g3_data, function(d) { return d.frequency; })]);

    g3_svg.append("g")
        .attr("class", "x-axis")
        .attr("transform", "translate(0," + height + ")")
        .call(g3_xAxis);

    g3_svg.append("g")
        .attr("class", "y-axis")
        .call(g3_yAxis)
      .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("Frequency");

    g3_svg.selectAll(".bar")
        .data(g3_data)
      .enter().append("rect")
        .attr("class", "bar")
        .attr("x", function(d) { return g3_x(d.name); })
        .attr("width", 5)//x.rangeBand())
        .attr("y", function(d) { return g3_y(d.frequency); })
        .attr("height", function(d) { return height - g3_y(d.frequency); })
        .on("mouseover", tooltipOver)
        .on("mouseout", tooltipOut);

    function g3_redraw() {
      g3_y.domain([0, d3.max(g3_data, function(d) { return d.frequency; })]);

      function calc3Ticks() {
        var m = d3.max(g3_data, function(d) { return d.frequency; })
        if(m<10)
          return m;
        else
          return 10;
      }

      g3_yAxis.ticks(calc3Ticks());
      g3_svg.selectAll("g .y-axis")
         .call(g3_yAxis);

      var bars = g3_svg.selectAll(".bar")
        .data(g3_data)
        .attr("y", function(d) { return g3_y(d.frequency); })
        .attr("height", function(d) { return height-g3_y(d.frequency); })

      d3.select("#graph3_counter").text(g3_counter);
    }


    function graph3_update() {
      d3.json("/ajax/clt_app/"+get_radio_value("gr3_rd")+".json", function(err, j) { console.log(j.data.sample); g3_data[j.data.sample_count_0].frequency++; g3_counter++; g3_redraw(); }).post()
    }

    var graph3TimerId;

    function toggleGraph3(){
      if(d3.select("#graph3_toggle").text() == "Start")
      {
        graph3TimerId = window.setInterval(graph3_update, document.getElementById("graph3_speed").value);
        d3.select("#graph3_toggle").text("Stop").attr("class", "btn_stop");
      }
      else
      {
        window.clearInterval(graph3TimerId);
        d3.select("#graph3_toggle").text("Start").attr("class", "btn_start");
      }
    }

    function resetGraph3(){
      g3_data.map(function(d){d.frequency=0;});
      g3_counter = 0;
      g3_redraw();
    }
    </script>
  </body>
</html>
